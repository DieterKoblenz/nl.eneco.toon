'use strict';

const request = require('request');
const _ = require('underscore');
const EventEmitter = require('events').EventEmitter;

const apiBaseUrl = 'https://api.toonapi.com/toon/api/v1/';

class Toon extends EventEmitter {

	/**
	 * Toon constructor, provide the API key and secret
	 * @constructor
	 */
	constructor(key, secret) {
		super();

		if (!key) console.error('node-toon: no client key provided');
		if (!secret) console.error('node-toon: no client secret provided');

		// Store key and secret for authorization later on
		this.key = key;
		this.secret = secret;

		// Defaults
		this.targetTemperature = undefined;
		this.measureTemperature = undefined;

		// Create fields for the access tokens
		this.accessToken = new Buffer(`${this.key}:${this.secret}`).toString('base64');
		this.refreshToken = undefined;

		console.log('node-toon: new Toon constructed');
	}

	/**
	 * Destroy client, clean up.
	 */
	destroy() {
		clearInterval(this.pollInterval);
		console.log('node-toon: client destroyed');
	}

	/**
	 * Queries the Toon API for the display status.
	 */
	getStatus() {
		return new Promise((resolve, reject) => {
			console.log('node-toon: get status');

			if (!this.pollInterval) {
				this.pollInterval = setInterval(() => {
					this.getStatus();
				}, 30000);
			}

			Promise.all([this._get('status'), this.getConsumptionElectricity(), this.getConsumptionGas()]).then(result => {
				this.meterPower = result[1];
				this.meterGas = result[2];

				if (typeof this.measureTemperature === 'undefined' && typeof this.targetTemperature === 'undefined') {
					// TODO check if this doesn't get called too often
					this.emit('initialized', this);
				}

				if (result[0] && result[0].thermostatInfo) {

					if (this.measureTemperature !== Math.round((result[0].thermostatInfo.currentTemp / 100) * 10) / 10 && typeof this.measureTemperature !== 'undefined')
						this.emit('measureTemperature', Math.round((result[0].thermostatInfo.currentTemp / 100) * 10) / 10);
					if (this.targetTemperature !== Math.round((result[0].thermostatInfo.currentSetpoint / 100) * 10) / 10 && typeof this.targetTemperature !== 'undefined')
						this.emit('targetTemperature', Math.round((result[0].thermostatInfo.currentSetpoint / 100) * 10) / 10);
					if (this.meterPower !== result[1] && typeof this.meterPower !== 'undefined')
						this.emit('meterPower', result[1]);
					if (this.meterGas !== result[2] && typeof this.meterGas !== 'undefined')
						this.emit('meterGas', result[2]);

					// Store updated values
					if (result[0].thermostatInfo.currentTemp)
						this.measureTemperature = Math.round((result[0].thermostatInfo.currentTemp / 100) * 10) / 10;

					if (result[0].thermostatInfo.currentSetpoint)
						this.targetTemperature = Math.round((result[0].thermostatInfo.currentSetpoint / 100) * 10) / 10;

					return resolve({
						measureTemperature: this.measureTemperature,
						targetTemperature: this.targetTemperature,
						meterPower: this.meterPower,
						meterGas: this.meterGas
					});
				}
				console.log('node-toon: no new data available');

				return resolve({
					measureTemperature: this.measureTemperature,
					targetTemperature: this.targetTemperature,
					meterPower: this.meterPower,
					meterGas: this.meterGas
				});
			}).catch(err => {
				console.log('node-toon: failed to get status, electricity or gas', err);
				return reject(err);
			});
		});
	}

	/**
	 * PUTs to the Toon API to set a new target temperature
	 * @param temperature temperature attribute of type integer
	 */
	setTargetTemperature(temperature) {
		return new Promise((resolve, reject) => {

			if (!temperature) {
				console.error('node-toon: no temperature provided');
				return reject('missing temperature');
			}

			console.log(`node-toon: set target temperature to ${temperature}`);

			this._put('temperature', { value: temperature * 100, scale: 'CELSIUS' }).then(() => {
				console.log(`node-toon: success setting temperature to ${temperature}`);
				this.targetTemperature = temperature;
				return resolve();
			}).catch(err => {
				console.error(`node-toon: failed to set temperature to ${temperature}`, err);

				// Retry in 3 seconds
				setTimeout(() => {

					this._put('temperature', { value: temperature * 100, scale: 'CELSIUS' }).then(() => {
						console.log(`node-toon: success setting temperature to ${temperature}`);
						this.targetTemperature = temperature;
						return resolve(temperature);
					}).catch(err => {
						console.error(`node-toon: failed to set temperature to ${temperature}`, err);
						return reject(err);
					});
				}, 3000);
			});
		});
	}

	/**
	 * Returns current target temperature
	 */
	getTargetTemperature() {
		return this.targetTemperature;
	}

	/**
	 * Returns current measured temperature
	 */
	getMeasureTemperature() {
		return this.measureTemperature;
	}

	/**
	 * Queries the Toon API for the temperature programs
	 */
	getTemperaturePrograms() {
		return new Promise((resolve, reject) => {
			this._get('temperature/programs')
				.then(result => resolve(result))
				.catch(err => reject(err));
		});
	}

	/**
	 * Queries the Toon API for the electricity consumption
	 * TODO only use peak? What is it?
	 */
	getConsumptionElectricity() {
		return new Promise((resolve, reject) => {
			this._get('consumption/electricity/data')
				.then(result => {
					if (result && result.hours) {
						const latest = _.max(result.hours, entry => entry.timestamp);
						if (!latest) return reject();
						if (typeof latest.peak !== 'undefined') {
							return resolve(latest.peak / 1000);
						}
						return reject();
					}
					return reject();
				})
				.catch(err => reject(err));
		});
	}

	/**
	 * Queries the Toon API for the gas consumption
	 */
	getConsumptionGas() {
		return new Promise((resolve, reject) => {
			this._get('consumption/gas/data')
				.then(result => {
					if (result && result.hours) {
						const latest = _.max(result.hours, entry => entry.timestamp);
						if (!latest) return reject();
						if (typeof latest.value !== 'undefined') {
							return resolve(latest.value / 1000);
						}
						return reject();
					}
					return reject();
				})
				.catch(err => reject(err));
		});
	}

	/**
	 * Fetches all agreements from the API, if there are more
	 * than one, the user may choose one
	 */
	getAgreements(stop) {
		return new Promise((resolve, reject) => {
			console.log('node-toon: get agreements');

			this._get('agreements').then(agreements => {
				if (agreements) {

					console.log(`node-toon: got ${agreements.length} agreements`);

					this.recentAgreements = agreements;

					return resolve(agreements);
				}

				// Check if allowed to retry
				if (!stop) {

					// Refresh access tokens
					this.refreshAccessToken().then(() => {

						// Try fetching agreements again
						this.getAgreements(true)
							.then(result => resolve(result))
							.catch(err => reject(err));
					});
				} else {
					console.error('node-toon: failed to get agreements');
					return reject('node-toon: failed to get agreements');
				}
			}).catch(err => {
				console.error('node-toon: failed to get agreements', err);
				return reject(err);
			});
		});
	}

	/**
	 * Selects an agreement (device?) and registers it to this
	 * toon object, this is a connection to the device
	 * @param agreementId
	 */
	setAgreement(agreementId) {
		return new Promise((resolve, reject) => {

			if (!agreementId) {
				console.error('node-toon: no agreementId provided');
				return reject('missing agreementId');
			}

			console.log(`node-toon: set agreement ${agreementId}`);

			// Make the request to set agreement
			this._post('agreements', { agreementId: agreementId }).then(result => {
				console.log('node-toon: successful post of agreement');

				// Check for updated target temperature
				this.getStatus()
					.then(() => resolve(result))
					.catch(err => reject(err));
			}).catch(err => {
				console.error('node-toon: failed to post agreement', err);
				return reject(err);
			});
		});
	}

	/**
	 * Fetches an access token from the Toon API using the
	 * athom callback service (redirect uri)
	 * @param code
	 * @param redirectUri
	 */
	getAccessTokens(code, redirectUri) {
		return new Promise((resolve, reject) => {

			if (!redirectUri) {
				console.error('node-toon: no redirectUri provided when getting access tokens');
				return reject('missing redirectUri');
			}

			if (!code) {
				console.error('node-toon: no code provided when getting access tokens');
				return reject('missing code');
			}

			// Request accessToken
			request.post({
				url: 'https://api.toonapi.com/token',
				form: {
					grant_type: 'authorization_code',
					client_id: this.key,
					client_secret: this.secret,
					redirect_uri: redirectUri,
					code: code,
				},
			}, (err, res, body) => {

				// Parse body
				try {
					body = JSON.parse(body);
				} catch (err) {
					console.error('node-toon: error parsing body from access tokens');
					return reject(err);
				}

				if (err || !body || !body.hasOwnProperty('access_token') || !body.hasOwnProperty('refresh_token')) {
					console.error('node-toon: error fetching access tokens', err);
					return reject(err);
				}

				console.log('node-toon: fetched new access tokens');

				// Store new tokens
				this.accessToken = body.access_token;
				this.refreshToken = body.refresh_token;

				// Emit refreshed event
				this.emit('refreshed', { access_token: this.accessToken, refresh_token: this.refreshToken });

				// Callback new tokens
				return resolve({
					access_token: body.access_token,
					refresh_token: body.refresh_token,
				});
			});
		});
	}

	/**
	 * Uses the refresh token to fetch a new access token,
	 * stores all new tokens internally
	 * @private
	 */
	refreshAccessToken() {
		return new Promise((resolve, reject) => {

			if (!this.refreshToken) {
				console.error('node-toon: no refreshToken provided');
				return reject('missing refreshToken');
			}

			// Refresh accessToken
			request.post({
				url: 'https://api.toonapi.com/token',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
				},
				form: {
					client_secret: this.secret,
					client_id: this.key,
					grant_type: 'refresh_token',
					refresh_token: this.refreshToken,
				},
			}, (err, res, body) => {

				// Parse body
				try {
					body = JSON.parse(body);
				} catch (err) {
					console.log('node-toon: error parsing body from refreshing tokens');
					return reject(err);
				}

				if (err || !body || !body.hasOwnProperty('access_token') || !body.hasOwnProperty('refresh_token')) {
					console.log('node-toon: error fetching refreshed tokens', err);
					return reject(err);
				}

				console.log('node-toon: fetched new access tokens');

				// Store new tokens
				this.accessToken = body.access_token;
				this.refreshToken = body.refresh_token;

				// Emit refreshed event
				this.emit('refreshed', { access_token: this.accessToken, refresh_token: this.refreshToken });

				// Callback new tokens
				return resolve({
					access_token: body.access_token,
					refresh_token: body.refresh_token,
				});
			});
		});
	}

	/**
	 * Convenience method that provides a basic PUT
	 * to the Toon API
	 * @param command Desired command to be PUT
	 * @param body Data to be updated
	 * @private
	 */
	_put(command, body) {
		if (!command) return Promise.reject('node-toon: no command provided');
		if (!body) return Promise.reject('node-toon: no body provided');
		if (!this.accessToken) return Promise.reject('node-toon: no accesstoken provided');

		// Perform the request
		return this._request({
			url: `${apiBaseUrl}${command}`,
			method: 'PUT',
			headers: {
				authorization: `Bearer ${this.accessToken}`,
				Accept: 'application/json',
			},
			json: body,
		});
	}

	/**
	 * Convenience method that provides a basic GET
	 * to the Toon API
	 * @param command Desired command to be GET
	 * @private
	 */
	_get(command) {
		if (!command) return Promise.reject('node-toon: no command provided');
		if (!this.accessToken) return Promise.reject('node-toon: no accesstoken provided');

		// Perform the request
		return this._request({
			url: `${apiBaseUrl}${command}`,
			method: 'GET',
			headers: {
				Authorization: `Bearer ${this.accessToken}`,
				Accept: 'application/json',
			},
		});
	}

	/**
	 * Convenience method that provides a basic POST
	 * to the Toon API
	 * @param command Desired command to be POST
	 * @param data Data to POST
	 * @private
	 */
	_post(command, data) {
		return new Promise((resolve, reject) => {
			if (!command) return reject('node-toon: no command provided');
			if (!data) return reject('node-toon: no body provided');
			if (!this.accessToken) return reject('node-toon: no accesstoken provided');

			// Perform request
			request({
				url: `${apiBaseUrl}${command}`,
				method: 'POST',
				headers: {
					Authorization: `Bearer ${this.accessToken}`,
					'Content-Type': 'application/json',
				},
				json: data,
			}, (err, response) => {
				if (err || !response || response.statusCode !== 200) {
					console.error('node-toon: error posting to Toon API', (err || response.statusCode));
					return reject((err || response.statusCode));
				}
				return resolve(response);
			});
		});
	}

	/**
	 * Convenience method that perfoms a request to
	 * the Toon api, using the options provided in the
	 * parameter options
	 * @param options Request options
	 * @private
	 */
	_request(options) {
		return new Promise((resolve, reject) => {

			// Start the request
			request(options, (error, response, body) => {
				if (!error && response.statusCode === 200) {
					if (body) {

						// Parse body
						try {
							body = JSON.parse(body);
						} catch (err) {
							console.error('node-toon: error parsing body');
							return reject(err);
						}
					}
					return resolve(body);
				}
				return reject((error || response.statusCode));
			});
		});
	}
}

module.exports = Toon;
