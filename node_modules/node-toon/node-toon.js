'use strict';

const request = require('request');
const EventEmitter = require('events').EventEmitter;

const apiBaseUrl = 'https://api.toonapi.com/toon/api/v1/';

class Toon extends EventEmitter {

	/**
	 * Toon constructor, provide the API key and secret
	 * @constructor
	 */
	constructor(key, secret) {
		super();

		// Store key and secret for authorization later on
		this.key = key;
		this.secret = secret;

		// Defaults
		this.targetTemperature = undefined;
		this.measureTemperature = undefined;

		// Create fields for the access tokens
		this.accessToken = new Buffer(`${this.key}:${this.secret}`).toString('base64');
		this.refreshToken = undefined;

		console.log('node-toon: new Toon constructed');
	}

	/**
	 * Queries the Toon API for the display status.
	 */
	getStatus() {
		return new Promise((resolve, reject) => {
			console.log('node-toon: get status');

			this._baseGET('status', (err, result) => {
				if (err) {
					console.error('node-toon: could not get status from API', err);
					return reject(err);
				}

				if (result && result.thermostatInfo) {

					// Store updated values
					if (result.thermostatInfo.currentTemp)
						this.measureTemperature = Math.round((result.thermostatInfo.currentTemp / 100) * 10) / 10;

					if (result.thermostatInfo.currentSetpoint)
						this.targetTemperature = Math.round((result.thermostatInfo.currentSetpoint / 100) * 10) / 10;

					// TODO check if this doesn't get called too often
					this.emit('initialized', this);

					return resolve(result.thermostatInfo);
				}

				console.log('node-toon: no new data available');
				return reject('node-toon: no new data available');
			});
		});
	}

	/**
	 * PUTs to the Toon API to set a new target temperature
	 * @param temperature temperature attribute of type integer
	 */
	setTargetTemperature(temperature) {
		return new Promise((resolve, reject) => {

			if (!temperature) {
				console.error('node-toon: no temperature provided');
				return reject('missing temperature');
			}

			console.log(`node-toon: set target temperature to ${temperature}`);

			this._basePUT('temperature', { value: temperature * 100, scale: 'CELSIUS' }, err => {
				if (err) {
					console.error(`node-toon: failed to set temperature to ${temperature}`, err);

					// Retry in 3 seconds
					setTimeout(() => {

						this._basePUT('temperature', { value: temperature * 100, scale: 'CELSIUS' }, err => {
							if (err) console.error(`node-toon: failed to set temperature to ${temperature}`, err);
							else console.log(`node-toon: success setting temperature to ${temperature}`);

							return reject(err);
						});
					}, 3000);
				} else {
					console.log(`node-toon: success setting temperature to ${temperature}`);
					return resolve();
				}
			});
		});
	}

	/**
	 * Returns current target temperature
	 */
	getTargetTemperature() {
		return this.targetTemperature;
	}

	/**
	 * Returns current measured temperature
	 */
	getMeasureTemperature() {
		return this.measureTemperature;
	}

	/**
	 * Queries the Toon API for the temperature programs
	 */
	getTemperaturePrograms() {
		return new Promise((resolve, reject) => {
			this._baseGET('temperature/programs', (err, result) => {
				if (err) return reject(err);
				return resolve(result);
			});
		});
	}

	/**
	 * Queries the Toon API for the electricity consumption
	 */
	getConsumptionElectricity() {
		return new Promise((resolve, reject) => {
			this._baseGET('consumption/electricity/data*', (err, result) => {
				if (err) return reject(err);
				return resolve(result);
			});
		});
	}

	/**
	 * Queries the Toon API for the gas consumption
	 */
	getConsumptionGas() {
		return new Promise((resolve, reject) => {
			this._baseGET('consumption/gas/data*', (err, result) => {
				if (err) return reject(err);
				return resolve(result);
			});
		});
	}

	/**
	 * Fetches all agreements from the API, if there are more
	 * than one, the user may choose one
	 */
	getAgreements(stop) {
		return new Promise((resolve, reject) => {

			console.log('node-toon: get agreements');

			this._baseGET('agreements', (err, agreements) => {
				if (err) {
					console.error('node-toon: failed to get agreements', err);
					return reject(err);
				}

				if (agreements) {

					console.log(`node-toon: got ${agreements.length} agreements`);

					this.recentAgreements = agreements;

					return resolve(agreements);
				}

				// Check if allowed to retry
				if (!stop) {

					// Refresh access tokens
					this.refreshAccessToken(() => {

						// Try fetching agreements again
						this.getAgreements(true)
							.then(result => resolve(result))
							.catch(err => reject(err));
					});
				} else {
					console.error(err, 'node-toon: failed to get agreements');
					return reject(err);
				}
			});
		});
	}

	/**
	 * Selects an agreement (device?) and registers it to this
	 * toon object, this is a connection to the device
	 * @param agreementId
	 */
	setAgreement(agreementId) {
		return new Promise((resolve, reject) => {

			if (!agreementId) {
				console.error('node-toon: no agreementId provided');
				return reject('missing agreementId');
			}

			console.log(`node-toon: set agreement ${agreementId}`);

			// Make the request to set agreement
			this._basePOST('agreements', { agreementId: agreementId }, (err, result) => {
				if (err) {
					console.error('node-toon: failed to post agreement', err);
					return reject(err);
				}

				console.log('node-toon: successful post of agreement');

				// Check for updated target temperature
				this.getStatus()
					.then(() => resolve(result))
					.catch(err => reject(err));
			});
		});
	}

	/**
	 * Fetches an access token from the Toon API using the
	 * athom callback service (redirect uri)
	 * @param code
	 * @param redirectUri
	 */
	getAccessTokens(code, redirectUri) {
		return new Promise((resolve, reject) => {

			if (!redirectUri) {
				console.error('node-toon: no redirectUri provided when getting access tokens');
				return reject('missing redirectUri');
			}

			if (!code) {
				console.error('node-toon: no code provided when getting access tokens');
				return reject('missing code');
			}

			// Request accessToken
			request.post({
				url: 'https://api.toonapi.com/token',
				rejectUnauthorized: false,
				form: {
					grant_type: 'authorization_code',
					client_id: this.key,
					client_secret: this.secret,
					redirect_uri: redirectUri,
					code: code,
				},
			}, (err, res, body) => {
				if (err || !body || !body.hasOwnProperty('access_token') || !body.hasOwnProperty('refresh_token')) {
					console.error('node-toon: error fetching access tokens', err);
					return reject(err);
				}

				// Parse body
				try {
					body = JSON.parse(body);
				} catch (err) {
					console.error('node-toon: error parsing body from access tokens');
					return reject(err);
				}

				console.log('node-toon: fetched new access tokens');

				// Store new tokens
				this.accessToken = body.access_token;
				this.refreshToken = body.refresh_token;

				// Emit refreshed event
				this.emit('refreshed', { access_token: this.accessToken, refresh_token: this.refreshToken });

				// Callback new tokens
				return resolve({
					access_token: body.access_token,
					refresh_token: body.refresh_token,
				});
			});
		});
	}

	/**
	 * Uses the refresh token to fetch a new access token,
	 * stores all new tokens internally
	 * @private
	 */
	refreshAccessToken() {
		return new Promise((resolve, reject) => {

			if (!this.refreshToken) {
				console.error('node-toon: no refreshToken provided');
				return reject('missing refreshToken');
			}

			// Refresh accessToken
			request.post({
				url: 'https://api.toonapi.com/token',
				rejectUnauthorized: false,
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
				},
				form: {
					client_secret: this.secret,
					client_id: this.key,
					grant_type: 'refresh_token',
					refresh_token: this.refreshToken,
				},
			}, (err, res, body) => {
				if (err || !body || !body.hasOwnProperty('access_token') || !body.hasOwnProperty('refresh_token')) {
					console.log('node-toon: error fetching refreshed tokens', err);
					return reject(err);
				}

				// Parse body
				try {
					body = JSON.parse(body);
				} catch (err) {
					console.log('node-toon: error parsing body from refreshing tokens');
					return reject(err);
				}

				console.log('node-toon: fetched new access tokens');

				// Store new tokens
				this.accessToken = body.access_token;
				this.refreshToken = body.refresh_token;

				// Emit refreshed event
				this.emit('refreshed', { access_token: this.accessToken, refresh_token: this.refreshToken });

				// Callback new tokens
				return resolve({
					access_token: body.access_token,
					refresh_token: body.refresh_token,
				});
			});
		});
	}

	/**
	 * Convenience method that provides a basic PUT
	 * to the Toon API
	 * @param command Desired command to be PUT
	 * @param body Data to be updated
	 * @private
	 */
	_basePUT(command, body) {
		if (!command) return Promise.reject('node-toon: no command provided');
		if (!body) return Promise.reject('node-toon: no body provided');
		if (!this.accessToken) return Promise.reject('node-toon: no accesstoken provided');

		// Perform the request
		return this._performRequest({
			url: `${apiBaseUrl}${command}`,
			method: 'PUT',
			rejectUnauthorized: false,
			headers: {
				authorization: `Bearer ${this.accessToken}`,
				Accept: 'application/json',
			},
			json: body,
		});
	}

	/**
	 * Convenience method that provides a basic GET
	 * to the Toon API
	 * @param command Desired command to be GET
	 * @private
	 */
	_baseGET(command) {
		if (!command) return Promise.reject('node-toon: no command provided');
		if (!this.accessToken) return Promise.reject('node-toon: no accesstoken provided');

		// Perform the request
		return this._performRequest({
			url: `${apiBaseUrl}${command}`,
			method: 'GET',
			rejectUnauthorized: false,
			headers: {
				Authorization: `Bearer ${this.accessToken}`,
				Accept: 'application/json',
			},
		});
	}

	/**
	 * Convenience method that provides a basic POST
	 * to the Toon API
	 * @param command Desired command to be POST
	 * @param data Data to POST
	 * @private
	 */
	_basePOST(command, data) {
		return new Promise((resolve, reject) => {
			if (!command) return reject('node-toon: no command provided');
			if (!data) return reject('node-toon: no body provided');
			if (!this.accessToken) return reject('node-toon: no accesstoken provided');

			// Perform request
			request({
				url: `${apiBaseUrl}${command}`,
				method: 'POST',
				headers: {
					Authorization: `Bearer ${this.accessToken}`,
					'Content-Type': 'application/json',
				},
				json: data,
			}, (err, response) => {
				if (err || !response || response.statusCode !== 200) {
					console.error('node-toon: error posting to Toon API', (err || response.statusCode));
					return reject((err || response.statusCode));
				}
				return resolve(response);
			});
		});
	}

	/**
	 * Convenience method that perfoms a request to
	 * the Toon api, using the options provided in the
	 * parameter options
	 * @param options Request options
	 * @private
	 */
	_performRequest(options) {
		return new Promise((resolve, reject) => {

			// Start the request
			request(options, (error, response, body) => {
				if (!error && body && response.statusCode === 200) {

					// Parse body
					try {
						body = JSON.parse(body);
					} catch (err) {
						console.error('node-toon: error parsing body');
						return reject(err);
					}
					return resolve(body);
				}
				return reject((error || response.statusCode));
			});
		});
	}
}

module.exports = Toon;
